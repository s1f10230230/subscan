# ãƒ¡ãƒ¼ãƒ«è§£æã‚¨ãƒ³ã‚¸ãƒ³å…ˆè¡Œå®Ÿè£…æŒ‡ç¤ºæ›¸

## æ¦‚è¦
Gmail APIé€£æºã«ã‚ˆã‚‹ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚«ãƒ¼ãƒ‰åˆ©ç”¨é€šçŸ¥ãƒ»ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æ¤œçŸ¥æ©Ÿèƒ½ã®æŠ€è¡“æ¤œè¨¼å®Ÿè£…ã€‚æœ¬æ ¼é–‹ç™ºå‰ã«ã‚³ã‚¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿç¾å¯èƒ½æ€§ã¨ç²¾åº¦ã‚’ç¢ºèªã™ã‚‹ã€‚

## æŠ€è¡“æ¤œè¨¼ç›®æ¨™
- **ç²¾åº¦ç›®æ¨™**: ä¸»è¦ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆNetflixã€æ¥½å¤©ã‚«ãƒ¼ãƒ‰ç­‰ï¼‰90%ä»¥ä¸Šã®æ¤œçŸ¥ç²¾åº¦
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™**: 100ä»¶ã®ãƒ¡ãƒ¼ãƒ«å‡¦ç†ã‚’10ç§’ä»¥å†…
- **Vercelåˆ¶é™å›é¿**: 15ç§’å®Ÿè¡Œåˆ¶é™å†…ã§ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†å®Ÿç¾

## Phase 1: Gmail APIåŸºç›¤ï¼ˆæ¨å®š1é€±é–“ï¼‰

### å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ
```
lib/
â”œâ”€â”€ email/
â”‚   â”œâ”€â”€ gmail-client.ts      # Gmail API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”œâ”€â”€ oauth-manager.ts     # OAuth2 ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†
â”‚   â”œâ”€â”€ email-fetcher.ts     # ãƒ¡ãƒ¼ãƒ«å–å¾—ãƒ»æ¤œç´¢
â”‚   â””â”€â”€ types.ts            # å‹å®šç¾©
â”œâ”€â”€ auth.ts                  # NextAuthè¨­å®šï¼ˆGmail OAuthç”¨ï¼‰
â””â”€â”€ encryption.ts           # ãƒˆãƒ¼ã‚¯ãƒ³æš—å·åŒ–

app/api/
â”œâ”€â”€ auth/[...nextauth]/route.ts  # Gmail OAuthå¯¾å¿œ
â”œâ”€â”€ email/
â”‚   â”œâ”€â”€ connect/route.ts     # Gmailæ¥ç¶šAPI
â”‚   â”œâ”€â”€ test-fetch/route.ts  # ãƒ†ã‚¹ãƒˆç”¨ãƒ¡ãƒ¼ãƒ«å–å¾—
â”‚   â””â”€â”€ oauth-callback/route.ts # OAuth ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯

components/
â””â”€â”€ email/
    â”œâ”€â”€ GmailConnector.tsx   # Gmailæ¥ç¶šUI
    â””â”€â”€ EmailTestViewer.tsx  # å–å¾—ãƒ¡ãƒ¼ãƒ«è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰

pages/
â””â”€â”€ email-test.tsx          # ãƒ¡ãƒ¼ãƒ«å–å¾—ãƒ†ã‚¹ãƒˆãƒšãƒ¼ã‚¸
```

### 1.1 Gmail OAuthè¨­å®š
```typescript
// lib/auth.ts - NextAuthè¨­å®šæ‹¡å¼µ
import NextAuth from "next-auth";
import GoogleProvider from "next-auth/providers/google";

export default NextAuth({
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          scope: [
            "openid",
            "email", 
            "profile",
            "https://www.googleapis.com/auth/gmail.readonly"
          ].join(" "),
          access_type: "offline",
          prompt: "consent"
        }
      }
    })
  ],
  callbacks: {
    async jwt({ token, account }) {
      if (account && account.provider === "google") {
        // Gmail ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æš—å·åŒ–ã—ã¦ä¿å­˜
        token.gmail_access_token = encrypt(account.access_token!);
        token.gmail_refresh_token = encrypt(account.refresh_token!);
        token.gmail_expires_at = account.expires_at;
      }
      return token;
    }
  }
});
```

### 1.2 Gmail API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
```typescript
// lib/email/gmail-client.ts
import { google } from 'googleapis';

export class GmailClient {
  private gmail: any;
  
  constructor(private accessToken: string) {
    const auth = new google.auth.OAuth2();
    auth.setCredentials({ access_token: accessToken });
    this.gmail = google.gmail({ version: 'v1', auth });
  }

  /**
   * ãƒ¡ãƒ¼ãƒ«æ¤œç´¢ï¼ˆã‚«ãƒ¼ãƒ‰ä¼šç¤¾ãƒ»ã‚µãƒ–ã‚¹ã‚¯ã‚µãƒ¼ãƒ“ã‚¹ã«ç‰¹åŒ–ï¼‰
   */
  async searchEmails(options: {
    dateRange: { start: Date; end: Date };
    maxResults?: number;
  }): Promise<EmailMessage[]> {
    try {
      // ç‰¹å®šã®é€ä¿¡è€…ã«çµã£ãŸæ¤œç´¢ã‚¯ã‚¨ãƒª
      const senders = [
        'noreply@account.netflix.com',
        'spotify.com',
        'rakuten-card.co.jp',
        'vpass.ne.jp',       // ä¸‰äº•ä½å‹ã‚«ãƒ¼ãƒ‰
        'jcb.co.jp',
        'amazon.co.jp',
        'adobe.com'
      ];
      
      const query = this.buildSearchQuery(senders, options.dateRange);
      
      const response = await this.gmail.users.messages.list({
        userId: 'me',
        q: query,
        maxResults: options.maxResults || 100
      });

      if (!response.data.messages) {
        return [];
      }

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è©³ç´°ã‚’ä¸¦åˆ—å–å¾—
      const messages = await Promise.all(
        response.data.messages.map(async (msg: any) => {
          const detail = await this.gmail.users.messages.get({
            userId: 'me',
            id: msg.id,
            format: 'full'
          });
          
          return this.parseEmailMessage(detail.data);
        })
      );

      return messages;
    } catch (error) {
      throw new GmailApiError('ãƒ¡ãƒ¼ãƒ«æ¤œç´¢ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    }
  }

  private buildSearchQuery(senders: string[], dateRange: { start: Date; end: Date }): string {
    const senderQuery = senders.map(sender => `from:${sender}`).join(' OR ');
    const dateQuery = `after:${this.formatGmailDate(dateRange.start)} before:${this.formatGmailDate(dateRange.end)}`;
    const keywordQuery = 'subject:(åˆ©ç”¨ OR æ”¯æ‰•ã„ OR payment OR subscription OR ãŠçŸ¥ã‚‰ã›)';
    
    return `(${senderQuery}) AND ${dateQuery} AND ${keywordQuery}`;
  }

  private parseEmailMessage(gmailMessage: any): EmailMessage {
    const headers = gmailMessage.payload.headers;
    const getHeader = (name: string) => 
      headers.find((h: any) => h.name.toLowerCase() === name.toLowerCase())?.value || '';

    let body = '';
    if (gmailMessage.payload.body?.data) {
      body = Buffer.from(gmailMessage.payload.body.data, 'base64').toString();
    } else if (gmailMessage.payload.parts) {
      // ãƒãƒ«ãƒãƒ‘ãƒ¼ãƒˆå¯¾å¿œ
      for (const part of gmailMessage.payload.parts) {
        if (part.mimeType === 'text/plain' && part.body?.data) {
          body = Buffer.from(part.body.data, 'base64').toString();
          break;
        }
      }
    }

    return {
      id: gmailMessage.id,
      subject: getHeader('Subject'),
      sender: getHeader('From'),
      receivedDate: new Date(parseInt(gmailMessage.internalDate)),
      body: body
    };
  }

  private formatGmailDate(date: Date): string {
    return date.toISOString().split('T')[0].replace(/-/g, '/');
  }
}

export interface EmailMessage {
  id: string;
  subject: string;
  sender: string;
  receivedDate: Date;
  body: string;
}

class GmailApiError extends Error {
  constructor(message: string, public originalError: any) {
    super(message);
    this.name = 'GmailApiError';
  }
}
```

### 1.3 ãƒ†ã‚¹ãƒˆç”¨API
```typescript
// app/api/email/test-fetch/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { GmailClient } from '@/lib/email/gmail-client';
import { decrypt } from '@/lib/encryption';

export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession();
    if (!session?.gmail_access_token) {
      return NextResponse.json({ error: 'Gmailæœªæ¥ç¶š' }, { status: 401 });
    }

    const accessToken = decrypt(session.gmail_access_token);
    const gmail = new GmailClient(accessToken);

    // éå»1ãƒ¶æœˆã®ãƒ¡ãƒ¼ãƒ«ã‚’å–å¾—ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
    const dateRange = {
      start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
      end: new Date()
    };

    const emails = await gmail.searchEmails({
      dateRange,
      maxResults: 50
    });

    return NextResponse.json({
      success: true,
      data: {
        emailCount: emails.length,
        emails: emails.map(email => ({
          id: email.id,
          subject: email.subject,
          sender: email.sender,
          receivedDate: email.receivedDate,
          bodyLength: email.body.length
        }))
      }
    });

  } catch (error) {
    console.error('Gmail test fetch error:', error);
    return NextResponse.json({
      success: false,
      error: error.message
    }, { status: 500 });
  }
}
```

## Phase 2: ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ãƒ»ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆæ¨å®š1.5é€±é–“ï¼‰

### å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ
```
lib/email/
â”œâ”€â”€ patterns/
â”‚   â”œâ”€â”€ subscription-patterns.ts    # ã‚µãƒ–ã‚¹ã‚¯ãƒ‘ã‚¿ãƒ¼ãƒ³å®šç¾©
â”‚   â”œâ”€â”€ card-patterns.ts           # ã‚¯ãƒ¬ã‚«ãƒ‘ã‚¿ãƒ¼ãƒ³å®šç¾©
â”‚   â””â”€â”€ pattern-matcher.ts         # ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ£ãƒ¼
â”œâ”€â”€ extractors/
â”‚   â”œâ”€â”€ amount-extractor.ts        # é‡‘é¡æŠ½å‡º
â”‚   â”œâ”€â”€ merchant-extractor.ts      # åº—èˆ—åæŠ½å‡º
â”‚   â”œâ”€â”€ date-extractor.ts          # æ—¥ä»˜æŠ½å‡º
â”‚   â””â”€â”€ base-extractor.ts          # åŸºåº•ã‚¯ãƒ©ã‚¹
â”œâ”€â”€ parser.ts                      # ãƒ¡ã‚¤ãƒ³è§£æã‚¨ãƒ³ã‚¸ãƒ³
â””â”€â”€ validation.ts                  # æŠ½å‡ºçµæœæ¤œè¨¼

__tests__/
â”œâ”€â”€ email/
â”‚   â”œâ”€â”€ fixtures/                  # ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«ã‚µãƒ³ãƒ—ãƒ«
â”‚   â”œâ”€â”€ parser.test.ts            # ãƒ‘ãƒ¼ã‚µãƒ¼ãƒ†ã‚¹ãƒˆ
â”‚   â””â”€â”€ patterns.test.ts          # ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ
```

### 2.1 ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³å®šç¾©
```typescript
// lib/email/patterns/subscription-patterns.ts
export interface SubscriptionPattern {
  serviceName: string;
  senderPatterns: RegExp[];
  subjectPatterns: RegExp[];
  amountPatterns: {
    regex: RegExp;
    currencyGroup: number;
    amountGroup: number;
  }[];
  merchantPatterns: RegExp[];
  billingCycle: 'MONTHLY' | 'YEARLY' | 'WEEKLY';
  confidence: number; // 0.0 - 1.0
  testCases: TestCase[];
}

interface TestCase {
  email: {
    subject: string;
    sender: string;
    body: string;
  };
  expected: {
    amount: number;
    currency: string;
    merchantName: string;
  };
}

export const SUBSCRIPTION_PATTERNS: SubscriptionPattern[] = [
  {
    serviceName: 'Netflix',
    senderPatterns: [
      /noreply@account\.netflix\.com/i,
      /info@account\.netflix\.com/i
    ],
    subjectPatterns: [
      /netflix.*ãŠæ”¯æ‰•ã„.*ãŠçŸ¥ã‚‰ã›/i,
      /netflix.*payment.*confirmation/i,
      /netflix.*receipt/i
    ],
    amountPatterns: [
      {
        regex: /Â¥([0-9,]+)/,
        currencyGroup: 0,
        amountGroup: 1
      },
      {
        regex: /JPY\s*([0-9,]+)/i,
        currencyGroup: 0,
        amountGroup: 1
      },
      {
        regex: /([0-9,]+)å††/,
        currencyGroup: 0,
        amountGroup: 1
      }
    ],
    merchantPatterns: [/Netflix/i],
    billingCycle: 'MONTHLY',
    confidence: 0.95,
    testCases: [
      {
        email: {
          subject: 'Netflix - ãŠæ”¯æ‰•ã„ã®ãŠçŸ¥ã‚‰ã›',
          sender: 'noreply@account.netflix.com',
          body: 'Netflix ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³ã®æœˆé¡æ–™é‡‘ Â¥1,490 ã®ãŠæ”¯æ‰•ã„ãŒå®Œäº†ã—ã¾ã—ãŸã€‚'
        },
        expected: {
          amount: 1490,
          currency: 'JPY',
          merchantName: 'Netflix'
        }
      }
    ]
  },
  
  {
    serviceName: 'Spotify',
    senderPatterns: [
      /noreply@spotify\.com/i,
      /info@spotify\.com/i
    ],
    subjectPatterns: [
      /spotify.*premium/i,
      /spotify.*subscription/i,
      /spotify.*ãŠæ”¯æ‰•ã„/i
    ],
    amountPatterns: [
      {
        regex: /\$([0-9.]+)/,
        currencyGroup: 0,
        amountGroup: 1
      },
      {
        regex: /Â¥([0-9,]+)/,
        currencyGroup: 0,
        amountGroup: 1
      }
    ],
    merchantPatterns: [/Spotify/i],
    billingCycle: 'MONTHLY',
    confidence: 0.90,
    testCases: [
      {
        email: {
          subject: 'Your Spotify Premium subscription',
          sender: 'noreply@spotify.com',
          body: 'Thank you for your Spotify Premium subscription. Amount: $9.99'
        },
        expected: {
          amount: 9.99,
          currency: 'USD',
          merchantName: 'Spotify'
        }
      }
    ]
  }
];
```

### 2.2 ãƒ¡ã‚¤ãƒ³è§£æã‚¨ãƒ³ã‚¸ãƒ³
```typescript
// lib/email/parser.ts
import { EmailMessage } from './gmail-client';
import { SUBSCRIPTION_PATTERNS } from './patterns/subscription-patterns';
import { CARD_PATTERNS } from './patterns/card-patterns';
import { AmountExtractor } from './extractors/amount-extractor';
import { MerchantExtractor } from './extractors/merchant-extractor';

export interface ParseResult {
  success: boolean;
  confidence: number; // 0.0 - 1.0
  type: 'SUBSCRIPTION' | 'TRANSACTION' | 'UNKNOWN';
  data?: {
    amount: number;
    currency: string;
    merchantName: string;
    serviceName?: string;
    billingCycle?: string;
  };
  errors: string[];
  matchedPattern?: string;
}

export class EmailParser {
  private amountExtractor = new AmountExtractor();
  private merchantExtractor = new MerchantExtractor();

  async parseEmail(email: EmailMessage): Promise<ParseResult> {
    try {
      // 1. ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
      const subscriptionResult = await this.checkSubscriptionPatterns(email);
      if (subscriptionResult.success && subscriptionResult.confidence >= 0.7) {
        return subscriptionResult;
      }

      // 2. ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚«ãƒ¼ãƒ‰åˆ©ç”¨é€šçŸ¥ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
      const cardResult = await this.checkCardPatterns(email);
      if (cardResult.success && cardResult.confidence >= 0.7) {
        return cardResult;
      }

      // 3. æ±ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
      const genericResult = await this.genericParsing(email);
      
      return {
        success: genericResult.success,
        confidence: Math.max(subscriptionResult.confidence, cardResult.confidence, genericResult.confidence),
        type: genericResult.type,
        data: genericResult.data,
        errors: [...subscriptionResult.errors, ...cardResult.errors, ...genericResult.errors],
        matchedPattern: 'GENERIC'
      };

    } catch (error) {
      return {
        success: false,
        confidence: 0,
        type: 'UNKNOWN',
        errors: [`Parse error: ${error.message}`]
      };
    }
  }

  private async checkSubscriptionPatterns(email: EmailMessage): Promise<ParseResult> {
    const emailText = `${email.subject} ${email.body}`.toLowerCase();
    const errors: string[] = [];

    for (const pattern of SUBSCRIPTION_PATTERNS) {
      try {
        // é€ä¿¡è€…ãƒã‚§ãƒƒã‚¯
        const senderMatch = pattern.senderPatterns.some(p => p.test(email.sender));
        if (!senderMatch) continue;

        // ä»¶åãƒã‚§ãƒƒã‚¯
        const subjectMatch = pattern.subjectPatterns.some(p => p.test(email.subject));
        if (!subjectMatch) continue;

        // é‡‘é¡æŠ½å‡º
        const amountResult = await this.extractAmountFromPattern(email, pattern);
        if (!amountResult.success) {
          errors.push(`${pattern.serviceName}: é‡‘é¡æŠ½å‡ºå¤±æ•—`);
          continue;
        }

        // åº—èˆ—åæŠ½å‡º
        const merchantResult = await this.extractMerchantFromPattern(email, pattern);

        return {
          success: true,
          confidence: pattern.confidence,
          type: 'SUBSCRIPTION',
          data: {
            amount: amountResult.amount!,
            currency: amountResult.currency!,
            merchantName: merchantResult.merchantName || pattern.serviceName,
            serviceName: pattern.serviceName,
            billingCycle: pattern.billingCycle
          },
          errors: [],
          matchedPattern: pattern.serviceName
        };

      } catch (error) {
        errors.push(`${pattern.serviceName}: ${error.message}`);
      }
    }

    return {
      success: false,
      confidence: 0,
      type: 'UNKNOWN',
      errors
    };
  }

  private async extractAmountFromPattern(
    email: EmailMessage, 
    pattern: SubscriptionPattern
  ): Promise<{success: boolean; amount?: number; currency?: string}> {
    const content = `${email.subject} ${email.body}`;

    for (const amountPattern of pattern.amountPatterns) {
      const match = content.match(amountPattern.regex);
      if (match) {
        const amountStr = match[amountPattern.amountGroup];
        const amount = parseFloat(amountStr.replace(/,/g, ''));
        
        if (!isNaN(amount) && amount > 0) {
          const currency = this.detectCurrency(match[0]);
          return { success: true, amount, currency };
        }
      }
    }

    return { success: false };
  }

  private detectCurrency(text: string): string {
    if (text.includes('Â¥') || text.includes('å††') || text.includes('JPY')) return 'JPY';
    if (text.includes('$') || text.includes('USD')) return 'USD';
    if (text.includes('â‚¬') || text.includes('EUR')) return 'EUR';
    return 'JPY'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
  }

  private async genericParsing(email: EmailMessage): Promise<ParseResult> {
    // æ±ç”¨çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
    const content = `${email.subject} ${email.body}`;
    
    // é‡‘é¡æŠ½å‡ºï¼ˆè¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³è©¦è¡Œï¼‰
    const amountResult = await this.amountExtractor.extract(content);
    if (!amountResult.success) {
      return {
        success: false,
        confidence: 0,
        type: 'UNKNOWN',
        errors: ['é‡‘é¡ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ']
      };
    }

    // åº—èˆ—åæŠ½å‡º
    const merchantResult = await this.merchantExtractor.extract(content);

    return {
      success: true,
      confidence: 0.4, // ä½ä¿¡é ¼åº¦
      type: 'TRANSACTION',
      data: {
        amount: amountResult.amount!,
        currency: amountResult.currency!,
        merchantName: merchantResult.merchantName || 'ä¸æ˜'
      },
      errors: [],
      matchedPattern: 'GENERIC'
    };
  }
}
```

### 2.3 ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹å®Ÿè£…
```typescript
// __tests__/email/parser.test.ts
import { EmailParser } from '@/lib/email/parser';
import { SUBSCRIPTION_PATTERNS } from '@/lib/email/patterns/subscription-patterns';

describe('EmailParser', () => {
  let parser: EmailParser;

  beforeEach(() => {
    parser = new EmailParser();
  });

  describe('Netflix detection', () => {
    test('should detect Netflix subscription payment', async () => {
      const email = {
        id: 'test-1',
        subject: 'Netflix - ãŠæ”¯æ‰•ã„ã®ãŠçŸ¥ã‚‰ã›',
        sender: 'noreply@account.netflix.com',
        receivedDate: new Date(),
        body: `
          ã„ã¤ã‚‚Netflixã‚’ã”åˆ©ç”¨ã„ãŸã ãã€ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚
          
          Netflix ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³ã®æœˆé¡æ–™é‡‘ Â¥1,490 ã®ãŠæ”¯æ‰•ã„ãŒå®Œäº†ã—ã¾ã—ãŸã€‚
          
          æ¬¡å›ã®ãŠæ”¯æ‰•ã„äºˆå®šæ—¥: 2024å¹´2æœˆ15æ—¥
          
          ã”è³ªå•ãŒã‚ã‚‹å ´åˆã¯ã€help.netflix.com ã‚’ã”ç¢ºèªãã ã•ã„ã€‚
        `
      };

      const result = await parser.parseEmail(email);

      expect(result.success).toBe(true);
      expect(result.confidence).toBeGreaterThan(0.9);
      expect(result.type).toBe('SUBSCRIPTION');
      expect(result.data?.amount).toBe(1490);
      expect(result.data?.currency).toBe('JPY');
      expect(result.data?.serviceName).toBe('Netflix');
      expect(result.matchedPattern).toBe('Netflix');
    });
  });

  describe('Spotify detection', () => {
    test('should detect Spotify subscription in USD', async () => {
      const email = {
        id: 'test-2',
        subject: 'Your Spotify Premium subscription',
        sender: 'noreply@spotify.com',
        receivedDate: new Date(),
        body: `
          Thanks for using Spotify Premium!
          
          Your monthly subscription payment of $9.99 has been processed.
          
          Next billing date: February 15, 2024
        `
      };

      const result = await parser.parseEmail(email);

      expect(result.success).toBe(true);
      expect(result.confidence).toBeGreaterThan(0.85);
      expect(result.type).toBe('SUBSCRIPTION');
      expect(result.data?.amount).toBe(9.99);
      expect(result.data?.currency).toBe('USD');
      expect(result.data?.serviceName).toBe('Spotify');
    });
  });

  // ãƒ‘ã‚¿ãƒ¼ãƒ³å®šç¾©ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’è‡ªå‹•å®Ÿè¡Œ
  describe('Pattern validation', () => {
    SUBSCRIPTION_PATTERNS.forEach(pattern => {
      pattern.testCases.forEach((testCase, index) => {
        test(`${pattern.serviceName} test case ${index + 1}`, async () => {
          const email = {
            id: `test-${pattern.serviceName}-${index}`,
            subject: testCase.email.subject,
            sender: testCase.email.sender,
            receivedDate: new Date(),
            body: testCase.email.body
          };

          const result = await parser.parseEmail(email);

          expect(result.success).toBe(true);
          expect(result.data?.amount).toBe(testCase.expected.amount);
          expect(result.data?.currency).toBe(testCase.expected.currency);
          expect(result.data?.merchantName).toBe(testCase.expected.merchantName);
        });
      });
    });
  });

  describe('Edge cases', () => {
    test('should handle email with no amount', async () => {
      const email = {
        id: 'test-no-amount',
        subject: 'Netflix - ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±å¤‰æ›´ã®ãŠçŸ¥ã‚‰ã›',
        sender: 'noreply@account.netflix.com',
        receivedDate: new Date(),
        body: 'ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè¨­å®šãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚'
      };

      const result = await parser.parseEmail(email);

      expect(result.success).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
    });

    test('should handle malformed amount formats', async () => {
      const email = {
        id: 'test-malformed',
        subject: 'Test payment',
        sender: 'test@example.com',
        receivedDate: new Date(),
        body: 'é‡‘é¡: Â¥1,abc,490å††ã§ã™'
      };

      const result = await parser.parseEmail(email);

      // æ±ç”¨ãƒ‘ãƒ¼ã‚µãƒ¼ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      expect(result.confidence).toBeLessThan(0.5);
    });
  });
});
```

## Phase 3: æ®µéšçš„å‡¦ç†ãƒ»Vercelåˆ¶é™å¯¾å¿œï¼ˆæ¨å®š1é€±é–“ï¼‰

### 3.1 ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¸ãƒ§ãƒ–ç®¡ç†
```typescript
// lib/email/background-processor.ts
interface ProcessingJob {
  id: string;
  userId: string;
  status: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'PARTIAL';
  progress: number;
  totalEmails: number;
  processedEmails: number;
  results: ParseResult[];
  errors: string[];
  createdAt: Date;
  updatedAt: Date;
}

export class EmailBackgroundProcessor {
  private readonly BATCH_SIZE = 20;
  private readonly MAX_EXECUTION_TIME = 12000; // 12ç§’ï¼ˆä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
  
  async processEmails(
    emails: EmailMessage[], 
    userId: string
  ): Promise<ProcessingJob> {
    const job: ProcessingJob = {
      id: crypto.randomUUID(),
      userId,
      status: 'PENDING',
      progress: 0,
      totalEmails: emails.length,
      processedEmails: 0,
      results: [],
      errors: [],
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // ã‚¸ãƒ§ãƒ–ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
    await this.saveJob(job);

    // æ®µéšçš„å‡¦ç†é–‹å§‹
    await this.processBatch(job, emails, 0);

    return job;
  }

  private async processBatch(
    job: ProcessingJob, 
    emails: EmailMessage[], 
    startIndex: number
  ): Promise<void> {
    const startTime = Date.now();
    const parser = new EmailParser();
    
    try {
      job.status = 'RUNNING';
      await this.updateJob(job);

      const endIndex = Math.min(startIndex + this.BATCH_SIZE, emails.length);
      const batch = emails.slice(startIndex, endIndex);

      // ãƒãƒƒãƒå‡¦ç†
      for (let i = 0; i < batch.length; i++) {
        const email = batch[i];
        
        try {
          const result = await parser.parseEmail(email);
          job.results.push(result);
          
          if (result.success && result.confidence >= 0.7) {
            // é«˜ä¿¡é ¼åº¦ã®çµæœã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
            await this.saveSuccessfulResult(job.userId, email, result);
          }
          
        } catch (error) {
          job.errors.push(`Email ${email.id}: ${error.message}`);
        }

        job.processedEmails++;
        job.progress = Math.round((job.processedEmails / job.totalEmails) * 100);

        // å®Ÿè¡Œæ™‚é–“ãƒã‚§ãƒƒã‚¯
        if (Date.now() - startTime > this.MAX_EXECUTION_TIME) {
          // æ¬¡ã®ãƒãƒƒãƒã‚’æ–°ã—ã„APIã‚³ãƒ¼ãƒ«ã§å‡¦ç†
          await this.scheduleNextBatch(job.id, endIndex);
          return;
        }
      }

      // ã“ã®ãƒãƒƒãƒå®Œäº†
      job.updatedAt = new Date();
      await this.updateJob(job);

      // ã¾ã å‡¦ç†ã™ã¹ããƒ¡ãƒ¼ãƒ«ãŒã‚ã‚‹å ´åˆ
      if (endIndex < emails.length) {
        await this.scheduleNextBatch(job.id, endIndex);
      } else {
        // å…¨å‡¦ç†å®Œäº†
        job.status = 'COMPLETED';
        job.progress = 100;
        await this.updateJob(job);
      }

    } catch (error) {
      job.status = 'FAILED';
      job.errors.push(`Batch processing error: ${error.message}`);
      await this.updateJob(job);
    }
  }

  private async scheduleNextBatch(jobId: string, nextStartIndex: number): Promise<void> {
    // Vercelã®ç’°å¢ƒã§ã¯å³åº§ã«æ¬¡ã®å‡¦ç†ã‚’å‘¼ã³å‡ºã—
    // æœ¬æ ¼é‹ç”¨æ™‚ã¯ã‚­ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆRedisç­‰ï¼‰ã‚’ä½¿ç”¨
    const response = await fetch('/api/email/process-batch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ jobId, startIndex: nextStartIndex })
    });

    if (!response.ok) {
      console.error('Failed to schedule next batch:', response.statusText);
    }
  }

  async getJobStatus(jobId: string): Promise<ProcessingJob | null> {
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã‚¸ãƒ§ãƒ–å–å¾—
    return await this.loadJob(jobId);
  }

  private async saveSuccessfulResult(
    userId: string, 
    email: EmailMessage, 
    result: ParseResult
  ): Promise<void> {
    if (!result.success || !result.data) return;

    // å–å¼•ã¾ãŸã¯ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
    if (result.type === 'SUBSCRIPTION') {
      await this.saveDetectedSubscription(userId, email, result);
    } else if (result.type === 'TRANSACTION') {
      await this.saveDetectedTransaction(userId, email, result);
    }
  }

  private async saveDetectedSubscription(
    userId: string, 
    email: EmailMessage, 
    result: ParseResult
  ): Promise<void> {
    // é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existing = await prisma.subscription.findFirst({
      where: {
        userId,
        serviceName: result.data!.serviceName,
        amount: result.data!.amount
      }
    });

    if (!existing) {
      await prisma.subscription.create({
        data: {
          userId,
          serviceName: result.data!.serviceName!,
          amount: result.data!.amount,
          currency: result.data!.currency,
          billingCycle: result.data!.billingCycle as any,
          detectionMethod: 'AUTO',
          confidenceScore: result.confidence,
          status: 'ACTIVE'
        }
      });
    }
  }

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå®Ÿè£…è©³ç´°ã¯çœç•¥ï¼‰
  private async saveJob(job: ProcessingJob): Promise<void> { /* ... */ }
  private async updateJob(job: ProcessingJob): Promise<void> { /* ... */ }
  private async loadJob(jobId: string): Promise<ProcessingJob | null> { /* ... */ }
}
```

### 3.2 ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤ºAPI
```typescript
// app/api/email/process-status/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { EmailBackgroundProcessor } from '@/lib/email/background-processor';

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const jobId = searchParams.get('jobId');
    
    if (!jobId) {
      return NextResponse.json({ error: 'Job ID required' }, { status: 400 });
    }

    const processor = new EmailBackgroundProcessor();
    const job = await processor.getJobStatus(jobId);

    if (!job) {
      return NextResponse.json({ error: 'Job not found' }, { status: 404 });
    }

    return NextResponse.json({
      success: true,
      data: {
        jobId: job.id,
        status: job.status,
        progress: job.progress,
        processedEmails: job.processedEmails,
        totalEmails: job.totalEmails,
        results: {
          successfulDetections: job.results.filter(r => r.success && r.confidence >= 0.7).length,
          subscriptionsFound: job.results.filter(r => r.type === 'SUBSCRIPTION' && r.success).length,
          transactionsFound: job.results.filter(r => r.type === 'TRANSACTION' && r.success).length
        },
        errors: job.errors,
        estimatedTimeRemaining: job.status === 'RUNNING' ? 
          this.calculateEstimatedTime(job) : 0
      }
    });

  } catch (error) {
    return NextResponse.json({
      success: false,
      error: error.message
    }, { status: 500 });
  }
}

function calculateEstimatedTime(job: ProcessingJob): number {
  if (job.progress === 0) return 0;
  
  const elapsed = Date.now() - job.createdAt.getTime();
  const remainingProgress = 100 - job.progress;
  
  return Math.round((elapsed / job.progress) * remainingProgress / 1000); // ç§’
}
```

## å®Œäº†æ¡ä»¶ãƒ»æ¤œè¨¼é …ç›®

### æŠ€è¡“æ¤œè¨¼æˆåŠŸåŸºæº–
- [ ] Gmail OAuthèªè¨¼ãƒ»ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†å‹•ä½œç¢ºèª
- [ ] 100ä»¶ã®ãƒ¡ãƒ¼ãƒ«å–å¾—ãŒ30ç§’ä»¥å†…ã§å®Œäº†
- [ ] Netflixã€Spotifyã€æ¥½å¤©ã‚«ãƒ¼ãƒ‰ã®æ¤œçŸ¥ç²¾åº¦90%ä»¥ä¸Š
- [ ] 15ç§’åˆ¶é™å†…ã§ã®æ®µéšçš„å‡¦ç†å‹•ä½œç¢ºèª
- [ ] ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°å‹•ä½œ

### ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹å®Œäº†åŸºæº–
- [ ] ä¸»è¦ã‚µãƒ¼ãƒ“ã‚¹20å€‹ã®æ¤œçŸ¥ãƒ†ã‚¹ãƒˆå…¨ã¦ãƒ‘ã‚¹
- [ ] ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ï¼ˆé‡‘é¡ãªã—ã€ä¸æ­£ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼‰ã®é©åˆ‡ãªå‡¦ç†
- [ ] å¤–è²¨ï¼ˆUSDï¼‰ã‚µãƒ–ã‚¹ã‚¯ã®æ­£ç¢ºãªæ¤œçŸ¥ãƒ»æ›ç®—
- [ ] è¤‡æ•°ãƒ¡ãƒ¼ãƒ«ã‚¢ã‚«ã‚¦ãƒ³ãƒˆå¯¾å¿œå‹•ä½œç¢ºèª

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¤œè¨¼
```typescript
// __tests__/performance/email-processing.test.ts
describe('Performance Tests', () => {
  test('should process 100 emails under 30 seconds', async () => {
    const startTime = Date.now();
    const emails = generateTestEmails(100);
    const processor = new EmailBackgroundProcessor();
    
    const job = await processor.processEmails(emails, 'test-user');
    
    // ã‚¸ãƒ§ãƒ–å®Œäº†ã¾ã§å¾…æ©Ÿ
    await waitForJobCompletion(job.id, 60000); // 60ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
    
    const endTime = Date.now();
    expect(endTime - startTime).toBeLessThan(30000); // 30ç§’ä»¥å†…
  });

  test('should handle Vercel 15-second limit', async () => {
    const emails = generateTestEmails(50);
    const processor = new EmailBackgroundProcessor();
    
    const job = await processor.processEmails(emails, 'test-user');
    
    // æ®µéšçš„å‡¦ç†ãŒæ­£å¸¸ã«å‹•ä½œã™ã‚‹ã“ã¨ã‚’ç¢ºèª
    expect(job.status).toMatch(/RUNNING|COMPLETED|PARTIAL/);
  });
});
```

---

## ğŸ¨ è¨­è¨ˆæ›¸è©³ç´°åŒ–

æ¬¡ã«ã€å®Ÿè£…ç²¾åº¦ã‚’é«˜ã‚ã‚‹ãŸã‚è¨­è¨ˆæ›¸ã‚’è©³ç´°åŒ–ã—ã¾ã™ï¼š

### è©³ç´°åŒ–é …ç›®

1. **ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ»UIè©³ç´°è¨­è¨ˆ**
2. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å…·ä½“ã‚±ãƒ¼ã‚¹**  
3. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–å®Ÿè£…è©³ç´°**
4. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æˆ¦ç•¥**
5. **é‹ç”¨ç›£è¦–é …ç›®è©³ç´°**

ã©ã®é …ç›®ã‹ã‚‰è©³ç´°åŒ–ã—ã¾ã™ã‹ï¼Ÿ

**æ¨å¥¨é †åº:**
1. **ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ** â†’ UIå®Ÿè£…ã®å…·ä½“çš„æŒ‡é‡
2. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°** â†’ å …ç‰¢æ€§ç¢ºä¿  
3. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£** â†’ ä¿¡é ¼æ€§å‘ä¸Š
4. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹** â†’ ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“å‘ä¸Š
5. **é‹ç”¨ç›£è¦–** â†’ é•·æœŸé‹ç”¨æº–å‚™

ã¾ãŸã¯ã€**ãƒ¡ãƒ¼ãƒ«è§£æã‚¨ãƒ³ã‚¸ãƒ³ã®å®Ÿè£…ã‚’å…ˆã«é–‹å§‹**ã—ã¦æŠ€è¡“æ¤œè¨¼ã‚’é€²ã‚ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚

ã©ã¡ã‚‰ã‚’å„ªå…ˆã—ã¾ã™ã‹ï¼Ÿ